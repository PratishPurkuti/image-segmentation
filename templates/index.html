<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instance Segmenter</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>

<body>
    <div class="container">
        <header>
            <h1>Instance Segmenter</h1>
            <p>Upload an image to extract individual objects with transparent backgrounds.</p>
        </header>

        <main>
            <div id="drop-zone" class="drop-zone">
                <span class="drop-zone__prompt">Drag & Drop image here or <span class="browse-link">Browse</span></span>
                <input type="file" name="file" class="drop-zone__input" accept="image/png, image/jpeg, image/jpg">
            </div>

            <div id="error-message" class="error-message" style="display: none;"></div>

            <div id="progress-container" class="progress-container" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-bar__fill"></div>
                </div>
                <p>Processing image...</p>
            </div>

            <div id="results-section" class="results-section" style="display: none;">
                <h2>Extracted Objects</h2>
                <div class="results-actions">
                    <a id="download-zip" href="#" class="btn btn-primary">Download All (ZIP)</a>
                    <button id="reset-btn" class="btn btn-secondary">Start Over</button>
                </div>
                <div id="results-grid" class="results-grid">
                    <!-- Thumbnails will be injected here -->
                </div>
            </div>
        </main>
    </div>

    <!-- Editor Modal -->
    <div id="editor-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Refine Segmentation</h2>
            </div>
            <div class="editor-workspace">
                <canvas id="editor-canvas"></canvas>
            </div>
            <div class="editor-toolbar">
                <div class="tool-group">
                    <span class="tool-label">Brush Size:</span>
                    <input type="range" id="brush-size" min="5" max="100" value="20">
                </div>
                <div class="tool-group">
                    <button id="undo-btn" class="btn btn-sm btn-secondary" title="Undo">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M9 14L4 9l5-5"></path>
                            <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"></path>
                        </svg>
                    </button>
                    <button id="redo-btn" class="btn btn-sm btn-secondary" title="Redo">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M15 14l5-5-5-5"></path>
                            <path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"></path>
                        </svg>
                    </button>
                </div>
                <div class="tool-group">
                    <button id="cancel-edit" class="btn btn-secondary">Cancel</button>
                    <button id="save-edit" class="btn btn-primary">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Editor Script -->
    <script src="{{ url_for('static', filename='editor.js') }}"></script>

    <script>
        let currentSessionId = null;
        let currentEditor = null;
        let currentEditingFile = null;

        document.querySelectorAll(".drop-zone__input").forEach((inputElement) => {
            const dropZoneElement = inputElement.closest(".drop-zone");

            dropZoneElement.addEventListener("click", (e) => {
                inputElement.click();
            });

            inputElement.addEventListener("change", (e) => {
                if (inputElement.files.length) {
                    handleFile(inputElement.files[0]);
                }
            });

            dropZoneElement.addEventListener("dragover", (e) => {
                e.preventDefault();
                dropZoneElement.classList.add("drop-zone--over");
            });

            ["dragleave", "dragend"].forEach((type) => {
                dropZoneElement.addEventListener(type, (e) => {
                    dropZoneElement.classList.remove("drop-zone--over");
                });
            });

            dropZoneElement.addEventListener("drop", (e) => {
                e.preventDefault();

                if (e.dataTransfer.files.length) {
                    inputElement.files = e.dataTransfer.files;
                    handleFile(e.dataTransfer.files[0]);
                }

                dropZoneElement.classList.remove("drop-zone--over");
            });
        });

        function handleFile(file) {
            const errorDiv = document.getElementById('error-message');
            const progressContainer = document.getElementById('progress-container');
            const resultsSection = document.getElementById('results-section');
            const dropZone = document.getElementById('drop-zone');

            // Reset UI
            errorDiv.style.display = 'none';
            resultsSection.style.display = 'none';
            progressContainer.style.display = 'block';
            dropZone.style.display = 'none'; // Hide drop zone while processing used to prevent re-upload during process

            // Client-side validation
            if (file.size > 10 * 1024 * 1024) {
                showError("File size exceeds 10MB limit.");
                progressContainer.style.display = 'none';
                dropZone.style.display = 'flex';
                return;
            }

            if (!['image/jpeg', 'image/png', 'image/jpg'].includes(file.type)) {
                showError("Invalid file type. Only JPG and PNG are allowed.");
                progressContainer.style.display = 'none';
                dropZone.style.display = 'flex';
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            // Animate progress bar artificially since we don't have real progress updates from backend
            const progressBar = document.querySelector('.progress-bar__fill');
            progressBar.style.width = '0%';
            let width = 0;
            const interval = setInterval(() => {
                if (width >= 90) clearInterval(interval);
                width++;
                progressBar.style.width = width + '%';
            }, 50);

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    clearInterval(interval);
                    progressBar.style.width = '100%';

                    if (data.error) {
                        showError(data.error);
                        progressContainer.style.display = 'none';
                        dropZone.style.display = 'flex';
                    } else {
                        currentSessionId = data.session_id; // Store session ID
                        displayResults(data);
                        progressContainer.style.display = 'none';
                    }
                })
                .catch(error => {
                    clearInterval(interval);
                    showError("An error occurred during upload.");
                    console.error(error);
                    progressContainer.style.display = 'none';
                    dropZone.style.display = 'flex';
                });
        }

        function showError(msg) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = msg;
            errorDiv.style.display = 'block';
        }

        function displayResults(data) {
            const resultsSection = document.getElementById('results-section');
            const resultsGrid = document.getElementById('results-grid');
            const downloadZip = document.getElementById('download-zip');
            const dropZone = document.getElementById('drop-zone');

            resultsGrid.innerHTML = '';

            // Set ZIP link
            downloadZip.href = `/download/${data.session_id}/${data.zip_file}`;

            data.files.forEach(filename => {
                const card = document.createElement('div');
                card.className = 'result-card';

                const img = document.createElement('img');
                const imgUrl = `/download/${data.session_id}/${filename}?t=${new Date().getTime()}`; // Add timestamp to bust cache
                img.src = imgUrl;
                img.alt = filename;

                const actionsDiv = document.createElement('div');
                actionsDiv.style.display = 'flex';
                actionsDiv.style.gap = '0.5rem';

                const downloadBtn = document.createElement('a');
                downloadBtn.href = `/download/${data.session_id}/${filename}`;
                downloadBtn.className = 'btn btn-sm';
                downloadBtn.innerHTML = 'Download';
                downloadBtn.download = filename; // Suggest filename
                downloadBtn.style.flex = '1';

                const editBtn = document.createElement('button');
                editBtn.className = 'btn btn-sm btn-secondary';
                editBtn.innerHTML = 'Edit';
                editBtn.style.flex = '1';
                editBtn.onclick = () => openEditor(filename);

                actionsDiv.appendChild(downloadBtn);
                actionsDiv.appendChild(editBtn);

                card.appendChild(img);
                card.appendChild(actionsDiv);
                resultsGrid.appendChild(card);
            });

            resultsSection.style.display = 'block';

            // Handle Reset
            document.getElementById('reset-btn').onclick = () => {
                resultsSection.style.display = 'none';
                dropZone.style.display = 'flex';
                // Effectively keeping the file input cleared for new selection
                document.querySelector('.drop-zone__input').value = '';
                currentSessionId = null;
            };
        }

        // --- Editor Logic ---

        function openEditor(filename) {
            currentEditingFile = filename;
            const modal = document.getElementById('editor-modal');
            const imgUrl = `/download/${currentSessionId}/${filename}?t=${new Date().getTime()}`;

            modal.style.display = 'flex';

            if (!currentEditor) {
                currentEditor = new ImageEditor('editor-canvas');

                document.getElementById('brush-size').addEventListener('input', (e) => {
                    currentEditor.setBrushSize(parseInt(e.target.value));
                });

                document.getElementById('undo-btn').onclick = () => currentEditor.undo();
                document.getElementById('redo-btn').onclick = () => currentEditor.redo();

                document.getElementById('cancel-edit').onclick = closeEditor;
                document.getElementById('save-edit').onclick = saveEdit;
            }

            currentEditor.loadImage(imgUrl);
        }

        function closeEditor() {
            document.getElementById('editor-modal').style.display = 'none';
            currentEditingFile = null;
        }

        function saveEdit() {
            const maskData = currentEditor.getMask();
            const saveBtn = document.getElementById('save-edit');
            const originalText = saveBtn.innerText;
            saveBtn.innerText = "Saving...";
            saveBtn.disabled = true;

            fetch('/refine', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    session_id: currentSessionId,
                    filename: currentEditingFile,
                    mask: maskData
                })
            })
                .then(response => response.json())
                .then(data => {
                    saveBtn.innerText = originalText;
                    saveBtn.disabled = false;

                    if (data.status === 'success') {
                        closeEditor();
                        // Refresh the specific image in the grid
                        updateImageInGrid(data.filename);
                    } else {
                        alert('Error saving: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(err => {
                    saveBtn.innerText = originalText;
                    saveBtn.disabled = false;
                    alert('Error saving: ' + err);
                });
        }

        function updateImageInGrid(filename) {
            // Find the image element with this filename
            const imgs = document.querySelectorAll('.result-card img');
            imgs.forEach(img => {
                if (img.alt === filename) {
                    // Update src with timestamp to force reload
                    img.src = `/download/${currentSessionId}/${filename}?t=${new Date().getTime()}`;
                }
            });

            // Also update the download link logic if needed (it points to same URL so it should be fine)
        }

    </script>
</body>

</html>